Using the NFFT
==============

This tutorial assumes that you are already familiar with what the 
Non-Uniform Fast Fourier Transform (NFFT) does and is used for.

Workflow
--------

Computation of the NFFT is done in 3 steps:
        
      - First a :class:`pynfft.NFFT` object is instantiated with the 
	right geometry paramaters and desired pre-allocation flags.
        
      - After setting the location of the non-uniform knots 
	:attr:`pynfft.NFFT.x`, the :meth:`pynfft.NFFT.precompute` 
	method is called in order to initialize the NFFT operator internals 
	appropriately.
	
      - Finally, the forward and adjoint NFFT are called using the 
	:meth:`pynfft.NFFT.trafo` and :meth:`pynfft.NFFT.adjoint` 
	methods. Input and output data can be accessed through the 
	:attr:`pynfft.NFFT.f` and :attr:`pynfft.NFFT.f_hat` 
	attributes.

Basic instantiation
-------------------

A new NFFT instance can be generated by specifying parameters `M`, 
the number of non-uniform samples and `N`, the shape of the uniform 
grid of the transformed data::

    >>> from pynfft import NFFT
    >>> Nfft = NFFT(N=(16, 16), M=92)
    >>> print Nfft.N
    (16, 16)
    >>> print Nfft.N_total
    256
    >>> print Nfft.M_total
    92

By default, the NFFT uses high precision parameters for the kernel 
width (m = 12) and oversampled grid size (n = 2 * N) parameters. 
These can be overriden at construct time (see `Advanced instantiation`).

Advanced instantiation
----------------------

More control over the precision, storage and speed requirements can be 
gained using the optional parameters of the :class:`pynfft.NFFT` 
constructor.

The trade-off between speed and precision can be tweaked by specifying 
custom values for parameters `m`, the convolution kernel width, and 
`n`, the oversampled grid size. Higher `m` and `n` lead to higher 
accuracy but may increase the computation time of the transforms significantly.

.. warning:: if `n` is specified manually, `n` must be superior or equal to N. 

In order to speed up the computation of the NFFT, some of the NFFT 
internals can be precomputed. This is controlled by precomputation 
flags specified in a tuple `flags` to the constructor. The default uses 
moderate precomputation with flags `PRE_PHI_HUT` and `PRE_PSI` enabled.

Maximum precomputation can be obtained using flag `PRE_FULL_PSI` instead of 
`PRE_PSI`. In this case, the NFFT operator requires more storage and the 
precomputation step takes more time, whilst execution of the transforms 
are the fastest.

For applications with lower storage requirements, flag `PRE_PHI_HUT` may be 
omitted. Lighter precomputation can also be obtained using flags `FG_PSI`,
`PRE_FG_PSI` or `PRE_LIN_PSI`.

External NumPy arrays for storage of `x`, `f`, and `f_hat` can also be
specified, provided they respect the data type and geometry of the transform 
and the arrays are c-contiguous.

Computing the forward and inverse NFFT
--------------------------------------

After instantiation, the location of the irregularly sampled data must be
passed to the NFFT instance using the :attr:`pynfft.NFFT.x` attribute.
Then, the NFFT operator has to be explictly precomputed.

        >>> from pynfft.util import vrand_shifted_unit_double
        >>> vrand_shifted_unit_double(Nfft.x)  # Nfft.x in [-0.5, 0.5]
        >>> Nfft.precompute()

After precomputation, the forward NFFT can be computed by first filling the 
:attr:`pynfft.NFFT.f_hat` attribute with the input data and then calling
the :meth:`pynfft.NFFT.trafo` method.

        >>> from pynfft.util import vrand_unit_complex
        >>> vrand_unit_complex(Nfft.f_hat)
        >>> Nfft.trafo()  # results stored in Nfft.f

Similar to the forward transform, the adjoint operation is performed by first 
filling the :attr:`pynfft.NFFT.f` attribute prior to calling the 
:meth:`pynfft.NFFT.adjoint` method.

        >>> from pynfft.util import vrand_unit_complex
        >>> vrand_unit_complex(Nfft.f)
        >>> Nfft.adjoint()  # results stored in Nfft.f_hat
