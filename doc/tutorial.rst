Getting started
===============

This tutorial assumes that you are already familiar with what the 
Non-Uniform Fast Fourier Transform (NFFT) does and is used for.

Using the NFFT
--------------

Computation of the NFFT is done in 3 steps: 
	- First a :class:`pynfft.nfft.NFFT` object is instantiated with the 
	right geometry paramaters and desired pre-allocation flags.
	- After setting the location of the non-uniform knots 
	:attr:`pynfft.nfft.NFFT.x`, the :meth:`pynfft.nfft.NFFT.precompute` 
	method is called in order to initialize the NFFT operator internals 
	appropriately.
	- Finally, the forward and adjoint NFFT are called using the 
	:meth:`pynfft.nfft.NFFT.trafo` and :meth:`pynfft.nfft.NFFT.adjoint` 
	methods. Input and output data can be accessed through the 
	:attr:`pynfft.nfft.NFFT.f` and :attr:`pynfft.nfft.NFFT.f_hat` 
	attributes.

Basic instantiation
-------------------

A new NFFT instance can be generated by specifying parameters `M`, 
the number of non-uniform samples and `N`, the shape of the uniform 
grid of the transformed data::

    >>> from pynfft.nfft import NFFT
    >>> Nfft = NFFT(N=(16, 16), M=92)
    >>> print Nfft.N
    (16, 16)
    >>> print Nfft.N_total
    256
    >>> print Nfft.M_total
    92

By default, the NFFT uses high precision parameters for the kernel 
width :attr:`pynfft.nfft.NFFT.m` and oversampled grid size 
:attr:`pynfft.nfft.NFFT.n` parameters. These can be overriden at 
construct time (see `Advanced instantiation`).

Advanced instantiation
----------------------

More control over the precision, storage and speed requirements can be 
gained using the optional parameters of the :class:`pynfft.nfft.NFFT` 
constructor.

The trade-off between speed and precision can be tweaked by specifying 
custom values for parameters `m`, the convolution kernel width, and 
`n`, the oversampled grid size. Higher `m` and `n` lead to higher 
accuracy but may significantly increase the computation time of the 
transforms.

% TODO: warning n >= N

In order to speed up the computation of the NFFT, some of the NFFT 
internals can be precomputed. This is controlled by precomputation 
flags specified in a tuple `flags` to the constructor. 





Computing the forward and inverse NFFT
--------------------------------------

By default, the NFFT uses high precision parameters for the kernel 
size :attr:`pynfft.nfft.NFFT.m` and oversampled grid size 
:attr:`pynfft.nfft.NFFT.n` parameters. These can be overriden at 
construct time::

	>>> print Nfft.m
	12
	>>> print Nfft.n
	(32, 32)
	
Using the solver
----------------
