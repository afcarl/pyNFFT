Using the NFFT
==============

This tutorial assumes that you are already familiar with what the 
Non-Uniform Fast Fourier Transform (NFFT) does and is used for.

Workflow
--------

Computation of the NFFT is done following these 3 steps:
        
      #. Instantiation of a :class:`pynfft.NFFT` object with the right geometry paramaters and desired pre-allocation flags.
        
      #. Set the location of the non-uniform knots in :attr:`pynfft.NFFT.x` and precompute the NFFT internals with :meth:`pynfft.NFFT.precompute`.
	
      #. Compute the forward and adjoint NFFT with the :meth:`pynfft.NFFT.trafo` and :meth:`pynfft.NFFT.adjoint` methods. Input and output data can be accessed through the :attr:`pynfft.NFFT.f` and :attr:`pynfft.NFFT.f_hat` attributes.

Basic instantiation
-------------------

A new NFFT instance can be generated by specifying parameters `M`, 
the number of non-uniform samples and `N`, the shape of the uniform 
grid of the transformed data::

    >>> from pynfft import NFFT
    >>> Nfft = NFFT(N=(16, 16), M=92)
    >>> print Nfft.N
    (16, 16)
    >>> print Nfft.N_total
    256
    >>> print Nfft.M_total
    92

By default, the NFFT uses high precision parameters for the kernel 
width (m = 12) and oversampled grid size (n = 2 * N) parameters. 
These can be overriden at construct time (see `Advanced instantiation`).

Advanced instantiation
----------------------

More control over the precision, storage and speed requirements can be 
gained using the optional parameters of the :class:`pynfft.NFFT` 
constructor.

The trade-off between speed and precision can be tweaked by specifying 
custom values for parameters `m`, the convolution kernel width, and 
`n`, the oversampled grid size. Higher `m` and `n` lead to higher 
accuracy but may increase the computation time of the transforms significantly.

.. warning:: if `n` is specified manually, `n` must be superior or equal to N. 

In order to speed up the computation of the NFFT, some of the NFFT 
internals can be precomputed. This is controlled by precomputation 
flags specified in a tuple `flags` to the constructor. The default uses 
moderate precomputation with flags `PRE_PHI_HUT` and `PRE_PSI` enabled.

Maximum precomputation can be obtained using flag `PRE_FULL_PSI` instead of 
`PRE_PSI`. In this case, the NFFT operator requires more storage and the 
precomputation step takes more time, whilst execution of the transforms 
are the fastest.

For applications with lower storage requirements, flag `PRE_PHI_HUT` may be 
omitted. Lighter precomputation can also be obtained using flags `FG_PSI`,
`PRE_FG_PSI` or `PRE_LIN_PSI`.

External NumPy arrays for storage of `x`, `f`, and `f_hat` can also be
specified, provided they respect the data type and geometry of the transform 
and the arrays are c-contiguous.

Computing the forward and inverse NFFT
--------------------------------------

After instantiation, the location of the irregularly sampled data must be
passed to the NFFT instance using the :attr:`pynfft.NFFT.x` attribute.
Then, the NFFT operator has to be explictly precomputed.

        >>> from pynfft.util import vrand_shifted_unit_double
        >>> vrand_shifted_unit_double(Nfft.x)  # Nfft.x in [-0.5, 0.5]
        >>> Nfft.precompute()

After precomputation, the forward NFFT can be computed by first filling the 
:attr:`pynfft.NFFT.f_hat` attribute with the input data and then calling
the :meth:`pynfft.NFFT.trafo` method.

        >>> from pynfft.util import vrand_unit_complex
        >>> vrand_unit_complex(Nfft.f_hat)
        >>> Nfft.trafo()  # results stored in Nfft.f

Similar to the forward transform, the adjoint operation is performed by first 
filling the :attr:`pynfft.NFFT.f` attribute prior to calling the 
:meth:`pynfft.NFFT.adjoint` method.

        >>> from pynfft.util import vrand_unit_complex
        >>> vrand_unit_complex(Nfft.f)
        >>> Nfft.adjoint()  # results stored in Nfft.f_hat


Using the solver
================

Workflow
--------

Computation of the inverse NFFT using the iterative solver is done 
following these 5 steps:

    #. Instantiate a :class:`pynfft.Solver` object,

    #. Initialize the solver attributes, including the input data :attr:`pynfft.Solver.y`, initial solution :attr:`pynfft.Solver.f_hat_iter` and optional weights :attr:`pynfft.Solver.w` and :attr:`pynfft.Solver.w_hat`,
    
    #. Initialize the solver internals, by calling :meth:`pynfft.Solver.before_loop`,
    
    #. Compute N iterations, by calling :meth:`pynfft.Solver.loop_one_step`,
    
    #. Read the current solution in :attr:`pynfft.Solver.f_hat_iter`.

Instantiation
-------------

In order to instantiate a :class:`pynfft.Solver` object, a valid 
instantiated and precomputed :class:`pynfft.NFFT` object is required. 
The iterative solver will use multiple forward and adjoint transforms 
from the supplied NFFT object, faster runtime speed will be obtained by 
using maximum precomputation for the NFFT object, via the 
`PRECOMPUTE_FULL_PSI` flag:

    >>> from pynfft import NFFT
    >>> Nfft = NFFT(N=(32, 32), M=96, flags='PRECOMPUTE_FULL_PSI')
    >>> Nfft.x = some_x
    >>> Nfft.precompute()

The solver is then instantiated with the previously initialized NFFT 
object. 

    >>> from pynfft import Solver
    >>> Solv = Solver(Nfft)  # CGNR default solver

A different solver can be chosen via the `flags` parameter, the 
default being the Conjugate Gradient of the first kind. Please consult 
the :class:`pynfft.Solver` documentation for more information.

    >>> Solv = Solver(Nfft, flags='CGNE')  # overrides solver

Use of weighting functions may boost the solver performance. These can 
be specified by the flags 'PRECOMPUTE_WEIGHT' and 'PRECOMPUTE_DAMP'.

    >>> Solv = Solver(Nfft, flags=('LANDWEBER', 'PRECOMPUTE_WEIGHT'))

By default, the weights of the non-uniform samples and Fourier coefficients, 
respectively accessed by :attr:`pynfft.Solver.w` and 
:attr:`pynfft.Solver.w_hat` are set to 1.

Initialization
--------------

Initialization of the solver is performed by calling the 
:meth:`pynfft.Solver.before_loop` method after setting the 
non-uniform samples :attr:`pynfft.Solver.y` and initial guess of the solution 
:attr:`pynfft.Solver.f_hat_iter`.

    >>> Solv.y = some_y
    >>> Solv.f_hat_iter = some_f_hat_iter
    >>> Solv.before_loop()

By default, the initial guess of the solution is set to 0, which makes the
first iteration of the solver behave like a call to the adjoint NFFT.


Iterative computation
---------------------

After successful initialization of the solver, a single iteration can be
performed by calling the :meth:`pynfft.Solver.loop_one_step` method.
The :class:`pynfft.Solver` class only supports one by one iteration. The user
is responsible for implementing the desired stopping condition for the solver,
which may differ between applications. Here are examples for the 2 most common
cases:

    - with a user-defined number of iterations:

    >>> nIter = 10  # set number of iterations to 10
    >>> for iIter in range(nIter):
    >>>	    Solv.loop_one_step()

    - with a threshold value on the residual values, accessible through the 
      :attr:`pynfft.Solver.r_iter` attribute:

    >>> threshold = 1e-3   # stop if changes between iteration is below 1%
    >>> try:
    >>>	    while True:
    >>>		Solv.loop_one_step()
    >>>		if(np.all(Solv.r_iter < threshold)):
    >>>		    raise StopCondition
    >>> except StopCondition:
    >>>	    # rest of the algorithm
